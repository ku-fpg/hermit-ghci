[1 of 1] Compiling QSortScript      ( QSortScript.hs, nothing )
[1 of 2] Compiling HList            ( HList.hs, HList.o )

HList.hs:22:11: Warning:
    Rule "repH ++" may never fire because ‘repH’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘repH’

HList.hs:23:11: Warning:
    Rule "repH []" may never fire because ‘repH’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘repH’

HList.hs:24:11: Warning:
    Rule "repH (:)" may never fire because ‘repH’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘repH’

HList.hs:27:11: Warning:
    Rule "repH-absH-fusion" may never fire
      because ‘repH’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘repH’
[2 of 2] Compiling Main             ( QSort.hs, QSort.o )
Setting phasers to stun... (port 3000) (ctrl-c to quit)
GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help
module Main where
  qsort ∷ ∀ a . Ord a → [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  $dShow ∷ Show [Integer]
  main ∷ IO ()
  main ∷ IO ()
[Done]

[1 of 1] Compiling QSortScript      ( QSortScript.hs, interpreted )
Ok, modules loaded: QSortScript.
module Main where
  qsort ∷ ∀ a . Ord a → [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  $dShow ∷ Show [Integer]
  main ∷ IO ()
  main ∷ IO ()
[Done]

qsort = λ △ $dOrd ds →
  case ds of wild ▲
    [] → [] ▲
    (:) a as →
      let ds =
            let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                cs =
                  case ds of wild ▲
                    (,) bs cs → cs
                bs =
                  case ds of wild ▲
                    (,) bs cs → bs
            in (,) ▲ ▲ bs cs
      in (++) ▲
              (qsort ▲ $dOrd
                     (case ds of ds ▲
                        (,) bs cs → bs))
              ((++) ▲ ((:) ▲ a ([] ▲))
                    (qsort ▲ $dOrd
                           (case ds of ds ▲
                              (,) bs cs → cs)))
[Done]

qsort = λ △ $dOrd ds →
  let rec qsort' = λ ds →
            case ds of wild ▲
              [] → [] ▲
              (:) a as →
                let ds =
                      let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                          cs =
                            case ds of wild ▲
                              (,) bs cs → cs
                          bs =
                            case ds of wild ▲
                              (,) bs cs → bs
                      in (,) ▲ ▲ bs cs
                in (++) ▲
                        (qsort' (case ds of ds ▲
                                   (,) bs cs → bs))
                        ((++) ▲ ((:) ▲ a ([] ▲))
                              (qsort' (case ds of ds ▲
                                         (,) bs cs → cs)))
  in qsort' ds
[Done]

qsort = λ △ $dOrd ds →
  let rec qsort' = λ ds →
            case ds of wild ▲
              [] → [] ▲
              (:) a as →
                let ds =
                      let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                          cs =
                            case ds of wild ▲
                              (,) bs cs → cs
                          bs =
                            case ds of wild ▲
                              (,) bs cs → bs
                      in (,) ▲ ▲ bs cs
                in (++) ▲
                        (qsort' (case ds of ds ▲
                                   (,) bs cs → bs))
                        ((++) ▲ ((:) ▲ a ([] ▲))
                              (qsort' (case ds of ds ▲
                                         (,) bs cs → cs)))
  in qsort' ds
[Done]

qsort' = λ ds →
  case ds of wild ▲
    [] → [] ▲
    (:) a as →
      let ds =
            let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                cs =
                  case ds of wild ▲
                    (,) bs cs → cs
                bs =
                  case ds of wild ▲
                    (,) bs cs → bs
            in (,) ▲ ▲ bs cs
      in (++) ▲
              (qsort' (case ds of ds ▲
                         (,) bs cs → bs))
              ((++) ▲ ((:) ▲ a ([] ▲))
                    (qsort' (case ds of ds ▲
                               (,) bs cs → cs)))
[Done]

qsort' =
  fix ▲
      (λ qsort' ds →
         case ds of wild ▲
           [] → [] ▲
           (:) a as →
             let ds =
                   let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                       cs =
                         case ds of wild ▲
                           (,) bs cs → cs
                       bs =
                         case ds of wild ▲
                           (,) bs cs → bs
                   in (,) ▲ ▲ bs cs
             in (++) ▲
                     (qsort' (case ds of ds ▲
                                (,) bs cs → bs))
                     ((++) ▲ ((:) ▲ a ([] ▲))
                           (qsort' (case ds of ds ▲
                                      (,) bs cs → cs))))
[Done]

fix ▲
    (λ qsort' ds →
       case ds of wild ▲
         [] → [] ▲
         (:) a as →
           let ds =
                 let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                     cs =
                       case ds of wild ▲
                         (,) bs cs → cs
                     bs =
                       case ds of wild ▲
                         (,) bs cs → bs
                 in (,) ▲ ▲ bs cs
           in (++) ▲
                   (qsort' (case ds of ds ▲
                              (,) bs cs → bs))
                   ((++) ▲ ((:) ▲ a ([] ▲))
                         (qsort' (case ds of ds ▲
                                    (,) bs cs → cs))))
[Done]

let g =
      (.) ▲ ▲ ▲ (repR ▲)
          ((.) ▲ ▲ ▲
               (λ qsort' ds →
                  case ds of wild ▲
                    [] → [] ▲
                    (:) a as →
                      let ds =
                            let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                                cs =
                                  case ds of wild ▲
                                    (,) bs cs → cs
                                bs =
                                  case ds of wild ▲
                                    (,) bs cs → bs
                            in (,) ▲ ▲ bs cs
                      in (++) ▲
                              (qsort' (case ds of ds ▲
                                         (,) bs cs → bs))
                              ((++) ▲ ((:) ▲ a ([] ▲))
                                    (qsort' (case ds of ds ▲
                                               (,) bs cs → cs))))
               (absR ▲))
    worker = fix ▲ g
in absR ▲ worker
[Done]

Forcing obligation: qsort-assumption
Goal:
  fix ▲
      ((.) ▲ ▲ ▲ (absR ▲)
           ((.) ▲ ▲ ▲ (repR ▲)
                (λ qsort' ds →
                   case ds of wild ▲
                     [] → [] ▲
                     (:) a as →
                       let ds =
                             let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                                 cs =
                                   case ds of wild ▲
                                     (,) bs cs → cs
                                 bs =
                                   case ds of wild ▲
                                     (,) bs cs → bs
                             in (,) ▲ ▲ bs cs
                       in (++) ▲
                               (qsort' (case ds of ds ▲
                                          (,) bs cs → bs))
                               ((++) ▲ ((:) ▲ a ([] ▲))
                                     (qsort' (case ds of ds ▲
                                                (,) bs cs → cs))))))
  ≡
  fix ▲
      (λ qsort' ds →
         case ds of wild ▲
           [] → [] ▲
           (:) a as →
             let ds =
                   let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                       cs =
                         case ds of wild ▲
                           (,) bs cs → cs
                       bs =
                         case ds of wild ▲
                           (,) bs cs → bs
                   in (,) ▲ ▲ bs cs
             in (++) ▲
                     (qsort' (case ds of ds ▲
                                (,) bs cs → bs))
                     ((++) ▲ ((:) ▲ a ([] ▲))
                           (qsort' (case ds of ds ▲
                                      (,) bs cs → cs))))Successfully proven: qsort-assumption
let g =
      (.) ▲ ▲ ▲ (repR ▲)
          ((.) ▲ ▲ ▲
               (λ qsort' ds →
                  case ds of wild ▲
                    [] → [] ▲
                    (:) a as →
                      let ds =
                            let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                                cs =
                                  case ds of wild ▲
                                    (,) bs cs → cs
                                bs =
                                  case ds of wild ▲
                                    (,) bs cs → bs
                            in (,) ▲ ▲ bs cs
                      in (++) ▲
                              (qsort' (case ds of ds ▲
                                         (,) bs cs → bs))
                              ((++) ▲ ((:) ▲ a ([] ▲))
                                    (qsort' (case ds of ds ▲
                                               (,) bs cs → cs))))
               (absR ▲))
    worker = fix ▲ g
in absR ▲ worker
[Done]

fix ▲ g
[Done]

let rec x =
          (λ f x → repH ▲ (f x)) ((λ qsort' ds →
                                     case ds of wild ▲
                                       [] → [] ▲
                                       (:) a as →
                                         let ds =
                                               let ds =
                                                     partition ▲
                                                               (λ ds →
                                                                  (<) ▲ $dOrd ds
                                                                      a)
                                                               as
                                                   cs =
                                                     case ds of wild ▲
                                                       (,) bs cs → cs
                                                   bs =
                                                     case ds of wild ▲
                                                       (,) bs cs → bs
                                               in (,) ▲ ▲ bs cs
                                         in (++) ▲
                                                 (qsort' (case ds of ds ▲
                                                            (,) bs cs → bs))
                                                 ((++) ▲ ((:) ▲ a ([] ▲))
                                                       (qsort' (case ds of ds ▲
                                                                  (,) bs cs →
                                                                    cs)))) ((λ g x →
                                                                               absH ▲
                                                                                    (g x)) x))
in x
[Done]

let rec x = λ x →
          repH ▲
               (case x of wild ▲
                  [] → [] ▲
                  (:) a as →
                    let ds =
                          let ds = partition ▲ (λ ds → (<) ▲ $dOrd ds a) as
                          in (,) ▲ ▲
                                 (case ds of wild ▲
                                    (,) bs cs → bs)
                                 (case ds of wild ▲
                                    (,) bs cs → cs)
                    in (++) ▲
                            (absH ▲
                                  (x (case ds of ds ▲
                                        (,) bs cs → bs)))
                            ((++) ▲ ((:) ▲ a ([] ▲))
                                  (absH ▲
                                        (x (case ds of ds ▲
                                              (,) bs cs → cs)))))
in x
[Done]

*** Exception: failed to parse result value: Null : Object not returned from Server
HERMIT> 
[Done]

Leaving GHCi.
ghc: user interrupt
Linking QSort ...
[starting HERMIT-shell v0.1.0.0 on QSort.hs]
[starting HERMIT v1.0.0.0 on QSort.hs]
% ghc QSort.hs -fforce-recomp -O2 -dcore-lint -fsimple-list-literals -fexpose-all-unfoldings -fplugin=HERMIT.GHCI -fplugin-opt=HERMIT.GHCI:Main: -fplugin-opt=HERMIT.GHCI:Main:QSortScript.hs -fplugin-opt=HERMIT.GHCI:Main:resume
