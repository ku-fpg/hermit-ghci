[1 of 2] Compiling HList            ( HList.hs, HList.o )

HList.hs:25:11: Warning:
    Rule "repH []" may never fire because ‘repH’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘repH’

HList.hs:26:11: Warning:
    Rule "repH (:)" may never fire because ‘repH’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘repH’

HList.hs:27:11: Warning:
    Rule "repH ++" may never fire because ‘repH’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘repH’

HList.hs:30:11: Warning:
    Rule "repH-absH-fusion" may never fire
      because ‘repH’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘repH’
[2 of 2] Compiling Main             ( Reverse.hs, Reverse.o )
Setting phasers to stun... (port 3000) (ctrl-c to quit)
GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help
module Main where
  rev ∷ ∀ a . [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  main ∷ IO ()
  main ∷ IO ()
[Done]

[1 of 1] Compiling ReverseScript    ( ReverseScript.hs, interpreted )
Ok, modules loaded: ReverseScript.
module Main where
  rev ∷ ∀ a . [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  main ∷ IO ()
  main ∷ IO ()
[Done]

++ [] (Not Proven)
  ∀ △ xs. (++) ▲ xs ([] ▲) ≡ xs
[Done]

Goal:
  ∀ △ xs. (++) ▲ xs ([] ▲) ≡ xs
[Done]

Goal:
  ∀ △ xs. myAppend ▲ xs ([] ▲) ≡ xs
[Done]

Forcing obligation: appendFix
Goal:
  ∀ △. (++) ▲ ≡ myAppend ▲Successfully proven: appendFix
Goal:
  ∀ △ xs. myAppend ▲ xs ([] ▲) ≡ xs
[Done]

Goal:
  ∀ △.
  (myAppend ▲ (undefined ▲) ([] ▲) ≡ undefined ▲)
  ∧
  ((myAppend ▲ ([] ▲) ([] ▲) ≡ [] ▲)
   ∧
   (∀ a b.
    (myAppend ▲ b ([] ▲) ≡ b)
    ⇒
    (myAppend ▲ ((:) ▲ a b) ([] ▲) ≡ (:) ▲ a b)))
[Done]

Goal:
  ∀ △.
  (undefined ▲ ≡ undefined ▲)
  ∧
  ((myAppend ▲ ([] ▲) ([] ▲) ≡ [] ▲)
   ∧
   (∀ a b.
    (myAppend ▲ b ([] ▲) ≡ b)
    ⇒
    (myAppend ▲ ((:) ▲ a b) ([] ▲) ≡ (:) ▲ a b)))
[Done]

Goal:
  ∀ △.
  (undefined ▲ ≡ undefined ▲)
  ∧
  (([] ▲ ≡ [] ▲)
   ∧
   (∀ a b.
    (myAppend ▲ b ([] ▲) ≡ b)
    ⇒
    ((:) ▲ a (myAppend ▲ b ([] ▲)) ≡ (:) ▲ a b)))
[Done]

Goal:
  ∀ △ a b.
  (myAppend ▲ b ([] ▲) ≡ b)
  ⇒
  ((:) ▲ a (myAppend ▲ b ([] ▲)) ≡ (:) ▲ a b)
[Done]

Goal:
  (myAppend ▲ b ([] ▲) ≡ b)
  ⇒
  ((:) ▲ a (myAppend ▲ b ([] ▲)) ≡ (:) ▲ a b)
[Done]

Assumed lemmas:
ind-hyp-0 (Built In)
  myAppend ▲ b ([] ▲) ≡ b
Goal:
  (:) ▲ a (myAppend ▲ b ([] ▲)) ≡ (:) ▲ a b
[Done]

Assumed lemmas:
ind-hyp-0 (Built In)
  myAppend ▲ b ([] ▲) ≡ b
Goal:
  (:) ▲ a b ≡ (:) ▲ a b
[Done]

Successfully proven: ++ []
module Main where
  rev ∷ ∀ a . [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  main ∷ IO ()
  main ∷ IO ()
[Done]

myAppend-assoc (Not Proven)
  ∀ △ xs ys zs.
  myAppend ▲ (myAppend ▲ xs ys) zs ≡ myAppend ▲ xs (myAppend ▲ ys zs)
[Done]

Goal:
  ∀ △ xs ys zs.
  myAppend ▲ (myAppend ▲ xs ys) zs ≡ myAppend ▲ xs (myAppend ▲ ys zs)
[Done]

Goal:
  ∀ △ ys zs.
  (myAppend ▲ (myAppend ▲ (undefined ▲) ys) zs
   ≡
   myAppend ▲ (undefined ▲) (myAppend ▲ ys zs))
  ∧
  ((myAppend ▲ (myAppend ▲ ([] ▲) ys) zs
    ≡
    myAppend ▲ ([] ▲) (myAppend ▲ ys zs))
   ∧
   (∀ a b.
    (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
    ⇒
    (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
     ≡
     myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs))))
[Done]

Goal:
  ∀ △ ys zs.
  (myAppend ▲ (myAppend ▲ (undefined ▲) ys) zs
   ≡
   myAppend ▲ (undefined ▲) (myAppend ▲ ys zs))
  ∧
  ((myAppend ▲ (myAppend ▲ ([] ▲) ys) zs
    ≡
    myAppend ▲ ([] ▲) (myAppend ▲ ys zs))
   ∧
   (∀ a b.
    (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
    ⇒
    (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
     ≡
     myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs))))
[Done]

Goal:
  (myAppend ▲ (myAppend ▲ (undefined ▲) ys) zs
   ≡
   myAppend ▲ (undefined ▲) (myAppend ▲ ys zs))
  ∧
  ((myAppend ▲ (myAppend ▲ ([] ▲) ys) zs
    ≡
    myAppend ▲ ([] ▲) (myAppend ▲ ys zs))
   ∧
   (∀ a b.
    (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
    ⇒
    (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
     ≡
     myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs))))
[Done]

Goal:
  (myAppend ▲ (myAppend ▲ (undefined ▲) ys) zs
   ≡
   myAppend ▲ (undefined ▲) (myAppend ▲ ys zs))
  ∧
  ((myAppend ▲ (myAppend ▲ ([] ▲) ys) zs
    ≡
    myAppend ▲ ([] ▲) (myAppend ▲ ys zs))
   ∧
   (∀ a b.
    (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
    ⇒
    (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
     ≡
     myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs))))
[Done]

Goal:
  myAppend ▲ (myAppend ▲ (undefined ▲) ys) zs
  ≡
  myAppend ▲ (undefined ▲) (myAppend ▲ ys zs)
[Done]

Goal:
  undefined ▲ ≡ undefined ▲
[Done]

Goal:
  true
[Done]

Goal:
  (true)
  ∧
  ((myAppend ▲ (myAppend ▲ ([] ▲) ys) zs
    ≡
    myAppend ▲ ([] ▲) (myAppend ▲ ys zs))
   ∧
   (∀ a b.
    (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
    ⇒
    (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
     ≡
     myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs))))
[Done]

Goal:
  (myAppend ▲ (myAppend ▲ ([] ▲) ys) zs
   ≡
   myAppend ▲ ([] ▲) (myAppend ▲ ys zs))
  ∧
  (∀ a b.
   (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
   ⇒
   (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
    ≡
    myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs)))
[Done]

Goal:
  (myAppend ▲ (myAppend ▲ ([] ▲) ys) zs
   ≡
   myAppend ▲ ([] ▲) (myAppend ▲ ys zs))
  ∧
  (∀ a b.
   (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
   ⇒
   (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
    ≡
    myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs)))
[Done]

Goal:
  myAppend ▲ (myAppend ▲ ([] ▲) ys) zs
  ≡
  myAppend ▲ ([] ▲) (myAppend ▲ ys zs)
[Done]

Goal:
  myAppend ▲ ys zs ≡ myAppend ▲ ys zs
[Done]

Goal:
  true
[Done]

Goal:
  (true)
  ∧
  (∀ a b.
   (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
   ⇒
   (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
    ≡
    myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs)))
[Done]

Goal:
  (true)
  ∧
  (∀ a b.
   (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
   ⇒
   (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
    ≡
    myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs)))
[Done]

Goal:
  ∀ a b.
  (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
  ⇒
  (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
   ≡
   myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs))
[Done]

Goal:
  (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
  ⇒
  (myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
   ≡
   myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs))
[Done]

Assumed lemmas:
ind-hyp-0 (Built In)
  myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs)
Goal:
  myAppend ▲ (myAppend ▲ ((:) ▲ a b) ys) zs
  ≡
  myAppend ▲ ((:) ▲ a b) (myAppend ▲ ys zs)
[Done]

Assumed lemmas:
ind-hyp-0 (Built In)
  myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs)
Goal:
  (λ △ ds ys →
     case ds of wild ▲
       [] → ys
       (:) x xs → (:) ▲ x (myAppend ▲ xs ys)) ▲
                                              ((λ △ ds ys →
                                                  case ds of wild ▲
                                                    [] → ys
                                                    (:) x xs →
                                                      (:) ▲ x
                                                          (myAppend ▲ xs ys)) ▲
                                                                              ((:) ▲
                                                                                   a
                                                                                   b)
                                                                              ys)
                                              zs
  ≡
  (λ △ ds ys →
     case ds of wild ▲
       [] → ys
       (:) x xs → (:) ▲ x (myAppend ▲ xs ys)) ▲ ((:) ▲ a b)
                                              ((λ △ ds ys →
                                                  case ds of wild ▲
                                                    [] → ys
                                                    (:) x xs →
                                                      (:) ▲ x
                                                          (myAppend ▲ xs ys)) ▲
                                                                              ys
                                                                              zs)
[Done]

Assumed lemmas:
ind-hyp-0 (Built In)
  myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs)
Goal:
  (:) ▲ a (myAppend ▲ (myAppend ▲ b ys) zs)
  ≡
  (:) ▲ a
      (myAppend ▲ b
                (case ys of wild ▲
                   [] → zs
                   (:) x xs → (:) ▲ x (myAppend ▲ xs zs)))
[Done]

Assumed lemmas:
ind-hyp-0 (Built In)
  myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs)
Goal:
  (:) ▲ a (myAppend ▲ (myAppend ▲ b ys) zs)
  ≡
  (:) ▲ a (myAppend ▲ b (myAppend ▲ ys zs))
[Done]

Assumed lemmas:
ind-hyp-0 (Built In)
  myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs)
Goal:
  (:) ▲ a (myAppend ▲ b (myAppend ▲ ys zs))
  ≡
  (:) ▲ a (myAppend ▲ b (myAppend ▲ ys zs))
[Done]

Assumed lemmas:
ind-hyp-0 (Built In)
  myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs)
Goal:
  true
[Done]

Goal:
  (true)
  ∧
  (∀ a b.
   (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
   ⇒
   (true))
[Done]

Goal:
  ∀ △ ys zs.
  (true)
  ∧
  ((true)
   ∧
   (∀ a b.
    (myAppend ▲ (myAppend ▲ b ys) zs ≡ myAppend ▲ b (myAppend ▲ ys zs))
    ⇒
    (true)))
[Done]

Successfully proven: myAppend-assoc
module Main where
  rev ∷ ∀ a . [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  main ∷ IO ()
  main ∷ IO ()
[Done]

repH [] (Not Proven)
  ∀ △. repH ▲ ([] ▲) ≡ id ▲
[Done]

Goal:
  ∀ △. repH ▲ ([] ▲) ≡ id ▲
[Done]

Goal:
  ∀ △. (++) ▲ ([] ▲) ≡ id ▲
[Done]

Goal:
  ∀ △ x. (++) ▲ ([] ▲) x ≡ id ▲ x
[Done]

Goal:
  ∀ △ x. myAppend ▲ ([] ▲) x ≡ id ▲ x
[Done]

Goal:
  ∀ △ x.
  case [] ▲ of wild ▲
    [] → x
    (:) x xs → (:) ▲ x (myAppend ▲ xs x)
  ≡
  id ▲ x
[Done]

Goal:
  ∀ △ x. x ≡ x
[Done]

Successfully proven: repH []
module Main where
  rev ∷ ∀ a . [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  main ∷ IO ()
  main ∷ IO ()
[Done]

repH (:) (Not Proven)
  ∀ △ x xs. repH ▲ ((:) ▲ x xs) ≡ (.) ▲ ▲ ▲ ((:) ▲ x) (repH ▲ xs)
[Done]

Goal:
  ∀ △ x xs. repH ▲ ((:) ▲ x xs) ≡ (.) ▲ ▲ ▲ ((:) ▲ x) (repH ▲ xs)
[Done]

Goal:
  ∀ △ x xs. (++) ▲ ((:) ▲ x xs) ≡ (.) ▲ ▲ ▲ ((:) ▲ x) ((++) ▲ xs)
[Done]

Goal:
  ∀ △ x xs.
  myAppend ▲ ((:) ▲ x xs) ≡ (.) ▲ ▲ ▲ ((:) ▲ x) (myAppend ▲ xs)
[Done]

Goal:
  ∀ △ x xs. myAppend ▲ ((:) ▲ x xs) ≡ λ x → (:) ▲ x (myAppend ▲ xs x)
[Done]

Goal:
  ∀ △ x xs.
  λ ys → (:) ▲ x (myAppend ▲ xs ys) ≡ λ x → (:) ▲ x (myAppend ▲ xs x)
[Done]

Successfully proven: repH (:)
module Main where
  rev ∷ ∀ a . [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  main ∷ IO ()
  main ∷ IO ()
[Done]

repH ++ (Not Proven)
  ∀ △ xs ys.
  repH ▲ ((++) ▲ xs ys) ≡ (.) ▲ ▲ ▲ (repH ▲ xs) (repH ▲ ys)
[Done]

Goal:
  ∀ △ xs ys.
  repH ▲ ((++) ▲ xs ys) ≡ (.) ▲ ▲ ▲ (repH ▲ xs) (repH ▲ ys)
[Done]

Goal:
  ∀ △ xs ys.
  (++) ▲ ((++) ▲ xs ys) ≡ (.) ▲ ▲ ▲ ((++) ▲ xs) ((++) ▲ ys)
[Done]

Goal:
  ∀ △ xs ys.
  myAppend ▲ (myAppend ▲ xs ys)
  ≡
  (.) ▲ ▲ ▲ (myAppend ▲ xs) (myAppend ▲ ys)
[Done]

Goal:
  ∀ △ xs ys.
  λ x → myAppend ▲ (myAppend ▲ xs ys) x
  ≡
  (.) ▲ ▲ ▲ (myAppend ▲ xs) (myAppend ▲ ys)
[Done]

Goal:
  ∀ △ xs ys.
  λ x → myAppend ▲ (myAppend ▲ xs ys) x
  ≡
  λ x → myAppend ▲ xs (myAppend ▲ ys x)
[Done]

Goal:
  ∀ △ xs ys zs.
  (λ x → myAppend ▲ (myAppend ▲ xs ys) x) zs
  ≡
  (λ x → myAppend ▲ xs (myAppend ▲ ys x)) zs
[Done]

Goal:
  ∀ △ xs ys zs.
  myAppend ▲ (myAppend ▲ xs ys) zs ≡ myAppend ▲ xs (myAppend ▲ ys zs)
[Done]

Goal:
  ∀ △ xs ys zs.
  myAppend ▲ (myAppend ▲ xs ys) zs ≡ myAppend ▲ xs (myAppend ▲ ys zs)
[Done]

Goal:
  myAppend ▲ (myAppend ▲ xs ys) zs ≡ myAppend ▲ xs (myAppend ▲ ys zs)
[Done]

Goal:
  true
[Done]

Goal:
  ∀ △ xs ys zs. true
[Done]

Successfully proven: repH ++
module Main where
  rev ∷ ∀ a . [a] → [a]
  absR ∷ ∀ a . ([a] → H a) → [a] → [a]
  repR ∷ ∀ a . ([a] → [a]) → [a] → H a
  main ∷ IO ()
  main ∷ IO ()
[Done]

rev = λ △ ds →
  case ds of wild ▲
    [] → [] ▲
    (:) x xs → (++) ▲ (rev ▲ xs) ((:) ▲ x ([] ▲))
[Done]

rev = λ △ →
  fix ▲
      (λ rev ds →
         case ds of wild ▲
           [] → [] ▲
           (:) x xs → (++) ▲ (rev xs) ((:) ▲ x ([] ▲)))
[Done]

fix ▲
    (λ rev ds →
       case ds of wild ▲
         [] → [] ▲
         (:) x xs → (++) ▲ (rev xs) ((:) ▲ x ([] ▲)))
[Done]

let g =
      (.) ▲ ▲ ▲ (repR ▲)
          ((.) ▲ ▲ ▲
               (λ rev ds →
                  case ds of wild ▲
                    [] → [] ▲
                    (:) x xs → (++) ▲ (rev xs) ((:) ▲ x ([] ▲)))
               (absR ▲))
    worker = fix ▲ g
in absR ▲ worker
[Done]

Forcing obligation: rev-assumption
Goal:
  fix ▲
      ((.) ▲ ▲ ▲ (absR ▲)
           ((.) ▲ ▲ ▲ (repR ▲)
                (λ rev ds →
                   case ds of wild ▲
                     [] → [] ▲
                     (:) x xs → (++) ▲ (rev xs) ((:) ▲ x ([] ▲)))))
  ≡
  fix ▲
      (λ rev ds →
         case ds of wild ▲
           [] → [] ▲
           (:) x xs → (++) ▲ (rev xs) ((:) ▲ x ([] ▲)))Goal:
  let rec x =
            absR ▲
                 (repR ▲
                       (λ ds →
                          case ds of wild ▲
                            [] → [] ▲
                            (:) x xs → (++) ▲ (x xs) ((:) ▲ x ([] ▲))))
  in x
  ≡
  let rec x = λ ds →
            case ds of wild ▲
              [] → [] ▲
              (:) x xs → (++) ▲ (x xs) ((:) ▲ x ([] ▲))
  in x
[Done]

Goal:
  let rec x = λ x →
            (++) ▲
                 (case x of wild ▲
                    [] → [] ▲
                    (:) x xs → (++) ▲ (x xs) ((:) ▲ x ([] ▲)))
                 ([] ▲)
  in x
  ≡
  let rec x = λ ds →
            case ds of wild ▲
              [] → [] ▲
              (:) x xs → (++) ▲ (x xs) ((:) ▲ x ([] ▲))
  in x
[Done]

Goal:
  let rec x = λ x →
            case x of wild ▲
              [] → [] ▲
              (:) x xs → (++) ▲ (x xs) ((:) ▲ x ([] ▲))
  in x
  ≡
  let rec x = λ ds →
            case ds of wild ▲
              [] → [] ▲
              (:) x xs → (++) ▲ (x xs) ((:) ▲ x ([] ▲))
  in x
[Done]

Successfully proven: rev-assumption
let g =
      (.) ▲ ▲ ▲ (repR ▲)
          ((.) ▲ ▲ ▲
               (λ rev ds →
                  case ds of wild ▲
                    [] → [] ▲
                    (:) x xs → (++) ▲ (rev xs) ((:) ▲ x ([] ▲)))
               (absR ▲))
    worker = fix ▲ g
in absR ▲ worker
[Done]

let g =
      (.) ▲ ▲ ▲ (λ eta → (λ f → (.) ▲ ▲ ▲ (repH ▲) f) eta)
          ((.) ▲ ▲ ▲
               (λ rev ds →
                  case ds of wild ▲
                    [] → [] ▲
                    (:) x xs → (++) ▲ (rev xs) ((:) ▲ x ([] ▲)))
               (λ eta → (λ g → (.) ▲ ▲ ▲ (absH ▲) g) eta))
    worker = fix ▲ g
in (λ g → (.) ▲ ▲ ▲ (absH ▲) g) worker
[Done]

let g = λ x →
      (λ eta → (λ f x → repH ▲ (f x)) eta) ((λ x →
                                               (λ rev ds →
                                                  case ds of wild ▲
                                                    [] → [] ▲
                                                    (:) x xs →
                                                      (++) ▲ (rev xs)
                                                           ((:) ▲ x
                                                                ([] ▲))) ((λ eta →
                                                                             (λ g x →
                                                                                absH ▲
                                                                                     (g x)) eta) x)) x)
    worker = fix ▲ g
in (λ g x → absH ▲ (g x)) worker
[Done]

λ x →
  absH ▲
       (fix ▲
            (λ x x →
               repH ▲
                    (case x of wild ▲
                       [] → [] ▲
                       (:) x xs → (++) ▲ (absH ▲ (x xs)) ((:) ▲ x ([] ▲))))
            x)
[Done]

*** Exception: failed to parse result value: Null : Object not returned from Server
HERMIT> Warning: Lemma appendFix was assumed but not proven.
appendFix
  ∀ △. (++) ▲ ≡ myAppend ▲
[Done]

Leaving GHCi.
ghc: user interrupt
Linking Reverse ...
[starting HERMIT-shell v0.1.0.0 on Reverse.hs]
[starting HERMIT v1.0.0.0 on Reverse.hs]
% ghc Reverse.hs -fforce-recomp -O2 -dcore-lint -fsimple-list-literals -fexpose-all-unfoldings -fplugin=HERMIT.GHCI -fplugin-opt=HERMIT.GHCI:Main: -fplugin-opt=HERMIT.GHCI:Main:ReverseScript.hs -fplugin-opt=HERMIT.GHCI:Main:resume
