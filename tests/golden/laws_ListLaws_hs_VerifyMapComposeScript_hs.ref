[1 of 1] Compiling ListLaws         ( ListLaws.hs, ListLaws.o )

ListLaws.hs:5:11: Warning:
    Rule "left-unit" may never fire because ‘bind’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘bind’

ListLaws.hs:7:11: Warning:
    Rule "right-unit" may never fire because ‘bind’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘bind’

ListLaws.hs:9:11: Warning:
    Rule "monad-assoc" may never fire because ‘bind’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘bind’

ListLaws.hs:10:11: Warning:
    Rule "monoid-left" may never fire
      because ‘mappen’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘mappen’

ListLaws.hs:12:11: Warning:
    Rule "monoid-right" may never fire
      because ‘mappen’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘mappen’

ListLaws.hs:14:11: Warning:
    Rule "monoid-assoc" may never fire
      because ‘mappen’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘mappen’

ListLaws.hs:16:11: Warning:
    Rule "nil-append" may never fire because ‘++’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘++’

ListLaws.hs:17:11: Warning:
    Rule "append-nil" may never fire because ‘++’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘++’

ListLaws.hs:18:11: Warning:
    Rule "append-nonempty" may never fire
      because ‘GHC.Types.:’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘GHC.Types.:’

ListLaws.hs:19:11: Warning:
    Rule "append-assoc" may never fire because ‘++’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘++’

ListLaws.hs:21:11: Warning:
    Rule "concat-unit" may never fire
      because ‘concat’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘concat’

ListLaws.hs:22:11: Warning:
    Rule "concat-of-toList" may never fire
      because ‘concat’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘concat’

ListLaws.hs:24:11: Warning:
    Rule "map-nonempty" may never fire because ‘map’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘map’

ListLaws.hs:29:12: Warning:
    Rule "map-compose" may never fire because ‘map’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘map’

ListLaws.hs:31:12: Warning:
    Rule "map-append" may never fire because ‘map’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘map’

ListLaws.hs:32:12: Warning:
    Rule "map-concat" may never fire because ‘map’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘map’

ListLaws.hs:33:12: Warning:
    Rule "concat-concat" may never fire
      because ‘concat’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘concat’

ListLaws.hs:34:12: Warning:
    Rule "concat-append" may never fire
      because ‘concat’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘concat’

ListLaws.hs:35:12: Warning:
    Rule "concat-nonempty" may never fire
      because ‘concat’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘concat’
Setting phasers to stun... (port 3000) (ctrl-c to quit)
GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help
module ListLaws where
  mempt ∷ ∀ a . [a]
  (++) ∷ ∀ a . [a] → [a] → [a]
  mappen ∷ ∀ a . [a] → [a] → [a]
  toList ∷ ∀ a . a → [a]
  concat ∷ ∀ a . [[a]] → [a]
  map ∷ ∀ a b . (a → b) → [a] → [b]
  retur ∷ ∀ a . a → [a]
  bind ∷ ∀ a b . [a] → (a → [b]) → [b]
[Done]

[1 of 1] Compiling VerifyMapComposeScript ( VerifyMapComposeScript.hs, interpreted )
Ok, modules loaded: VerifyMapComposeScript.
map-compose (Not Proven)
  ∀ △ △ △ f g xs.
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) xs ≡ map ▲ ▲ f (map ▲ ▲ g xs)
[Done]

Goal:
  ∀ △ △ △ f g xs.
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) xs ≡ map ▲ ▲ f (map ▲ ▲ g xs)
[Done]

Goal:
  ∀ △ △ △ f g.
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) (undefined ▲)
   ≡
   map ▲ ▲ f (map ▲ ▲ g (undefined ▲)))
  ∧
  ((map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ map ▲ ▲ f (map ▲ ▲ g ([] ▲)))
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
    ⇒
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
     ≡
     map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))))
[Done]

Goal:
  ∀ △ △ △ f g.
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) (undefined ▲)
   ≡
   map ▲ ▲ f (map ▲ ▲ g (undefined ▲)))
  ∧
  ((map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ map ▲ ▲ f (map ▲ ▲ g ([] ▲)))
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
    ⇒
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
     ≡
     map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))))
[Done]

Goal:
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) (undefined ▲)
   ≡
   map ▲ ▲ f (map ▲ ▲ g (undefined ▲)))
  ∧
  ((map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ map ▲ ▲ f (map ▲ ▲ g ([] ▲)))
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
    ⇒
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
     ≡
     map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))))
[Done]

Goal:
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) (undefined ▲)
   ≡
   map ▲ ▲ f (map ▲ ▲ g (undefined ▲)))
  ∧
  ((map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ map ▲ ▲ f (map ▲ ▲ g ([] ▲)))
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
    ⇒
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
     ≡
     map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))))
[Done]

Goal:
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) (undefined ▲)
  ≡
  map ▲ ▲ f (map ▲ ▲ g (undefined ▲))
[Done]

Goal:
  (λ △ △ ds ds →
     case ds of wild ▲
       [] → [] ▲
       (:) a as → (:) ▲ (ds a) (map ▲ ▲ ds as)) ▲ ▲ ((.) ▲ ▲ ▲ f g)
                                                (undefined ▲)
  ≡
  (λ △ △ ds ds →
     case ds of wild ▲
       [] → [] ▲
       (:) a as → (:) ▲ (ds a) (map ▲ ▲ ds as)) ▲ ▲ f
                                                ((λ △ △ ds ds →
                                                    case ds of wild ▲
                                                      [] → [] ▲
                                                      (:) a as →
                                                        (:) ▲ (ds a)
                                                            (map ▲ ▲ ds as)) ▲ ▲
                                                                             g
                                                                             (undefined ▲))
[Done]

Goal:
  true
[Done]

Goal:
  (true)
  ∧
  ((map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ map ▲ ▲ f (map ▲ ▲ g ([] ▲)))
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
    ⇒
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
     ≡
     map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))))
[Done]

Goal:
  (true)
  ∧
  ((map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ map ▲ ▲ f (map ▲ ▲ g ([] ▲)))
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
    ⇒
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
     ≡
     map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))))
[Done]

Goal:
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ map ▲ ▲ f (map ▲ ▲ g ([] ▲)))
  ∧
  (∀ a b.
   (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
   ⇒
   (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
    ≡
    map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b))))
[Done]

Goal:
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ map ▲ ▲ f (map ▲ ▲ g ([] ▲))
[Done]

Goal:
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) ([] ▲) ≡ [] ▲
[Done]

Goal:
  case [] ▲ of wild ▲
    [] → [] ▲
    (:) a as → (:) ▲ ((.) ▲ ▲ ▲ f g a) (map ▲ ▲ ((.) ▲ ▲ ▲ f g) as)
  ≡
  [] ▲
[Done]

Goal:
  true
[Done]

Goal:
  (true)
  ∧
  ((true)
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
    ⇒
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
     ≡
     map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))))
[Done]

Goal:
  (true)
  ∧
  ((true)
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
    ⇒
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
     ≡
     map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))))
[Done]

Goal:
  (true)
  ∧
  (∀ a b.
   (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
   ⇒
   (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
    ≡
    map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b))))
[Done]

Goal:
  ∀ a b.
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
  ⇒
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
   ≡
   map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))
[Done]

Goal:
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b))
  ⇒
  (map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
   ≡
   map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b)))
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
  ≡
  map ▲ ▲ f (map ▲ ▲ g ((:) ▲ a b))
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) ((:) ▲ a b)
  ≡
  (:) ▲ (f (g a)) (map ▲ ▲ (λ x → f (g x)) b)
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  (λ △ △ ds ds →
     case ds of wild ▲
       [] → [] ▲
       (:) a as → (:) ▲ (ds a) (map ▲ ▲ ds as)) ▲ ▲ ((.) ▲ ▲ ▲ f g)
                                                ((:) ▲ a b)
  ≡
  (:) ▲ (f (g a)) (map ▲ ▲ (λ x → f (g x)) b)
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  (:) ▲ (f (g a)) (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b)
  ≡
  (:) ▲ (f (g a)) (map ▲ ▲ (λ x → f (g x)) b)
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  (:) ▲ (f (g a)) (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b)
  ≡
  (:) ▲ (f (g a)) (map ▲ ▲ (λ x → f (g x)) b)
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  (:) ▲ (f (g a)) (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b)
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  (:) ▲ (f (g a)) (map ▲ ▲ ((λ △ △ △ f g x → f (g x)) ▲ ▲ ▲ f g) b)
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  (:) ▲ (f (g a)) (map ▲ ▲ (λ x → f (g x)) b)
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  (:) ▲ (f (g a)) (map ▲ ▲ (λ x → f (g x)) b)
  ≡
  (:) ▲ (f (g a)) (map ▲ ▲ (λ x → f (g x)) b)
[Done]

Assumed lemmas: 
ind-hyp-0 (Built In)
  map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)
Goal:
  true
[Done]

Goal:
  (true)
  ∧
  ((true)
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)) ⇒ (true)))
[Done]

Goal:
  ∀ △ △ △ f g.
  (true)
  ∧
  ((true)
   ∧
   (∀ a b.
    (map ▲ ▲ ((.) ▲ ▲ ▲ f g) b ≡ map ▲ ▲ f (map ▲ ▲ g b)) ⇒ (true)))
[Done]

Successfully proven: map-compose
module ListLaws where
  mempt ∷ ∀ a . [a]
  (++) ∷ ∀ a . [a] → [a] → [a]
  mappen ∷ ∀ a . [a] → [a] → [a]
  toList ∷ ∀ a . a → [a]
  concat ∷ ∀ a . [[a]] → [a]
  map ∷ ∀ a b . (a → b) → [a] → [b]
  retur ∷ ∀ a . a → [a]
  bind ∷ ∀ a b . [a] → (a → [b]) → [b]
[Done]

HERMIT> 
[Done]

Leaving GHCi.
ghc: user interrupt
[starting HERMIT-shell v0.1.0.0 on ListLaws.hs]
[starting HERMIT v1.0.0.0 on ListLaws.hs]
% ghc ListLaws.hs -fforce-recomp -O2 -dcore-lint -fsimple-list-literals -fexpose-all-unfoldings -fplugin=HERMIT.GHCI -fplugin-opt=HERMIT.GHCI:ListLaws: -fplugin-opt=HERMIT.GHCI:ListLaws:VerifyMapComposeScript.hs -fplugin-opt=HERMIT.GHCI:ListLaws:resume
