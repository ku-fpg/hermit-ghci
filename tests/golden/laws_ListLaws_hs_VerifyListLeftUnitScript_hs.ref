[1 of 1] Compiling ListLaws         ( ListLaws.hs, ListLaws.o )
Setting phasers to stun... (port 3000) (ctrl-c to quit)
GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
module ListLaws where
  mempt ∷ ∀ a . [a]
  (++) ∷ ∀ a . [a] → [a] → [a]
  mappen ∷ ∀ a . [a] → [a] → [a]
  toList ∷ ∀ a . a → [a]
  concat ∷ ∀ a . [[a]] → [a]
  map ∷ ∀ a b . (a → b) → [a] → [b]
  retur ∷ ∀ a . a → [a]
  bind ∷ ∀ a b . [a] → (a → [b]) → [b]
[Done]

[1 of 3] Compiling VerifyAppendNilScript ( VerifyAppendNilScript.hs, interpreted )
[2 of 3] Compiling VerifyConcatUnitScript ( VerifyConcatUnitScript.hs, interpreted )
[3 of 3] Compiling VerifyListLeftUnitScript ( VerifyListLeftUnitScript.hs, interpreted )
Ok, modules loaded: VerifyListLeftUnitScript, VerifyConcatUnitScript, VerifyAppendNilScript.
left-unit (Not Proven)
  ∀ △ △ x f. bind ▲ ▲ (retur ▲ x) f ≡ f x
[Done]

concat-unit (Not Proven)
  ∀ △ x. concat ▲ ((:) ▲ x ([] ▲)) ≡ x
[Done]

append-nil (Not Proven)
  ∀ △ xs. (++) ▲ xs ([] ▲) ≡ xs
[Done]

Goal:
  ∀ △ xs. (++) ▲ xs ([] ▲) ≡ xs
[Done]

Goal:
  ∀ △.
  ((++) ▲ (undefined ▲) ([] ▲) ≡ undefined ▲)
  ∧
  (((++) ▲ ([] ▲) ([] ▲) ≡ [] ▲)
   ∧
   (∀ a b.
    ((++) ▲ b ([] ▲) ≡ b) ⇒ ((++) ▲ ((:) ▲ a b) ([] ▲) ≡ (:) ▲ a b)))
[Done]

Goal:
  ∀ △.
  ((++) ▲ (undefined ▲) ([] ▲) ≡ undefined ▲)
  ∧
  (((++) ▲ ([] ▲) ([] ▲) ≡ [] ▲)
   ∧
   (∀ a b.
    ((++) ▲ b ([] ▲) ≡ b) ⇒ ((++) ▲ ((:) ▲ a b) ([] ▲) ≡ (:) ▲ a b)))
[Done]

Goal:
  ((++) ▲ (undefined ▲) ([] ▲) ≡ undefined ▲)
  ∧
  (((++) ▲ ([] ▲) ([] ▲) ≡ [] ▲)
   ∧
   (∀ a b.
    ((++) ▲ b ([] ▲) ≡ b) ⇒ ((++) ▲ ((:) ▲ a b) ([] ▲) ≡ (:) ▲ a b)))
[Done]

Goal:
  (true)
  ∧
  (((++) ▲ ([] ▲) ([] ▲) ≡ [] ▲)
   ∧
   (∀ a b.
    ((++) ▲ b ([] ▲) ≡ b) ⇒ ((++) ▲ ((:) ▲ a b) ([] ▲) ≡ (:) ▲ a b)))
[Done]

Goal:
  (true)
  ∧
  ((true)
   ∧
   (∀ a b.
    ((++) ▲ b ([] ▲) ≡ b) ⇒ ((++) ▲ ((:) ▲ a b) ([] ▲) ≡ (:) ▲ a b)))
[Done]

Goal:
  (true)
  ∧
  ((true) ∧ (∀ a b. ((++) ▲ b ([] ▲) ≡ b) ⇒ ((:) ▲ a b ≡ (:) ▲ a b)))
[Done]

Goal:
  ∀ △.
  (true)
  ∧
  ((true) ∧ (∀ a b. ((++) ▲ b ([] ▲) ≡ b) ⇒ ((:) ▲ a b ≡ (:) ▲ a b)))
[Done]

Successfully proven: append-nil
module ListLaws where
  mempt ∷ ∀ a . [a]
  (++) ∷ ∀ a . [a] → [a] → [a]
  mappen ∷ ∀ a . [a] → [a] → [a]
  toList ∷ ∀ a . a → [a]
  concat ∷ ∀ a . [[a]] → [a]
  map ∷ ∀ a b . (a → b) → [a] → [b]
  retur ∷ ∀ a . a → [a]
  bind ∷ ∀ a b . [a] → (a → [b]) → [b]
[Done]

Goal:
  ∀ △ x. concat ▲ ((:) ▲ x ([] ▲)) ≡ x
[Done]

Goal:
  ∀ △ x. concat ▲ ((:) ▲ x ([] ▲)) ≡ x
[Done]

Goal:
  concat ▲ ((:) ▲ x ([] ▲)) ≡ x
[Done]

Goal:
  (λ △ ds →
     case ds of wild ▲
       [] → [] ▲
       (:) x xs → (++) ▲ x (concat ▲ xs)) ▲ ((:) ▲ x ([] ▲))
  ≡
  x
[Done]

Goal:
  (++) ▲ x (concat ▲ ([] ▲)) ≡ x
[Done]

Goal:
  (++) ▲ x
       ((λ △ ds →
           case ds of wild ▲
             [] → [] ▲
             (:) x xs → (++) ▲ x (concat ▲ xs)) ▲ ([] ▲))
  ≡
  x
[Done]

Goal:
  (++) ▲ x ([] ▲) ≡ x
[Done]

Goal:
  x ≡ x
[Done]

Goal:
  ∀ △ x. x ≡ x
[Done]

Successfully proven: concat-unit
module ListLaws where
  mempt ∷ ∀ a . [a]
  (++) ∷ ∀ a . [a] → [a] → [a]
  mappen ∷ ∀ a . [a] → [a] → [a]
  toList ∷ ∀ a . a → [a]
  concat ∷ ∀ a . [[a]] → [a]
  map ∷ ∀ a b . (a → b) → [a] → [b]
  retur ∷ ∀ a . a → [a]
  bind ∷ ∀ a b . [a] → (a → [b]) → [b]
[Done]

Goal:
  ∀ △ △ x f. bind ▲ ▲ (retur ▲ x) f ≡ f x
[Done]

Goal:
  ∀ △ △ x f.
  (λ △ △ as k → concat ▲ (map ▲ ▲ k as)) ▲ ▲ (toList ▲ x) f ≡ f x
[Done]

Goal:
  ∀ △ △ x f. concat ▲ (map ▲ ▲ f (toList ▲ x)) ≡ f x
[Done]

Goal:
  ∀ △ △ x f.
  concat ▲ (map ▲ ▲ f ((λ △ x → (:) ▲ x ([] ▲)) ▲ x)) ≡ f x
[Done]

Goal:
  ∀ △ △ x f. concat ▲ (map ▲ ▲ f ((:) ▲ x ([] ▲))) ≡ f x
[Done]

Goal:
  ∀ △ △ x f.
  concat ▲
         ((λ △ △ ds ds →
             case ds of wild ▲
               [] → [] ▲
               (:) a as → (:) ▲ (ds a) (map ▲ ▲ ds as)) ▲ ▲ f ((:) ▲ x ([] ▲)))
  ≡
  f x
[Done]

Goal:
  ∀ △ △ x f. concat ▲ ((:) ▲ (f x) (map ▲ ▲ f ([] ▲))) ≡ f x
[Done]

Goal:
  ∀ △ △ x f.
  concat ▲
         ((:) ▲ (f x)
              ((λ △ △ ds ds →
                  case ds of wild ▲
                    [] → [] ▲
                    (:) a as → (:) ▲ (ds a) (map ▲ ▲ ds as)) ▲ ▲ f ([] ▲)))
  ≡
  f x
[Done]

Goal:
  ∀ △ △ x f. concat ▲ ((:) ▲ (f x) ([] ▲)) ≡ f x
[Done]

Goal:
  ∀ △ △ x f. concat ▲ ((:) ▲ (f x) ([] ▲)) ≡ f x
[Done]

Goal:
  concat ▲ ((:) ▲ (f x) ([] ▲)) ≡ f x
[Done]

Goal:
  f x ≡ f x
[Done]

Goal:
  true
[Done]

Goal:
  ∀ △ △ x f. true
[Done]

Successfully proven: left-unit
module ListLaws where
  mempt ∷ ∀ a . [a]
  (++) ∷ ∀ a . [a] → [a] → [a]
  mappen ∷ ∀ a . [a] → [a] → [a]
  toList ∷ ∀ a . a → [a]
  concat ∷ ∀ a . [[a]] → [a]
  map ∷ ∀ a b . (a → b) → [a] → [b]
  retur ∷ ∀ a . a → [a]
  bind ∷ ∀ a b . [a] → (a → [b]) → [b]
[Done]

HERMIT> 
[Done]

Leaving GHCi.
ghc: user interrupt
[starting HERMIT-shell v0.1.0.0 on ListLaws.hs]
[starting HERMIT v1.0.0.0 on ListLaws.hs]
% ghc ListLaws.hs -fforce-recomp -O2 -dcore-lint -fsimple-list-literals -fexpose-all-unfoldings -fplugin=HERMIT.GHCI -fplugin-opt=HERMIT.GHCI:ListLaws: -fplugin-opt=HERMIT.GHCI:ListLaws:VerifyListLeftUnitScript.hs -fplugin-opt=HERMIT.GHCI:ListLaws:resume -w
