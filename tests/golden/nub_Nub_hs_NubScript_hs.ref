[1 of 1] Compiling NubScript        ( NubScript.hs, nothing )
[1 of 1] Compiling Main             ( Nub.hs, Nub.o )

Nub.hs:26:11: Warning:
    Rule "filter-fusion" may never fire
      because ‘filter’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘filter’

Nub.hs:27:11: Warning:
    Rule "member-fusion" may never fire because ‘&&’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘&&’
Setting phasers to stun... (port 3000) (ctrl-c to quit)
GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help
module Main where
  absN ∷ ([Int] → Set Int → [Int]) → [Int] → [Int]
  filter ∷ ∀ a . (a → Bool) → [a] → [a]
  repN ∷ ([Int] → [Int]) → [Int] → Set Int → [Int]
  $dShow ∷ Show [Int]
  nub ∷ [Int] → [Int]
  main ∷ IO ()
  main ∷ IO ()
[Done]

[1 of 1] Compiling NubScript        ( NubScript.hs, interpreted )
Ok, modules loaded: NubScript.
module Main where
  absN ∷ ([Int] → Set Int → [Int]) → [Int] → [Int]
  filter ∷ ∀ a . (a → Bool) → [a] → [a]
  repN ∷ ([Int] → [Int]) → [Int] → Set Int → [Int]
  $dShow ∷ Show [Int]
  nub ∷ [Int] → [Int]
  main ∷ IO ()
  main ∷ IO ()
[Done]

module Main where
  absN ∷ ([Int] → Set Int → [Int]) → [Int] → [Int]
  filter ∷ ∀ a . (a → Bool) → [a] → [a]
  repN ∷ ([Int] → [Int]) → [Int] → Set Int → [Int]
  $dShow ∷ Show [Int]
  nub ∷ [Int] → [Int]
  main ∷ IO ()
  main ∷ IO ()
[Done]

nub ∷ [Int] → [Int]
nub = λ ds →
  case ds of wild [Int]
    [] → [] Int
    (:) x xs →
      (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
[Done]

nub ∷ [Int] → [Int]
nub =
  fix ([Int] → [Int])
      (λ nub ds →
         case ds of wild [Int]
           [] → [] Int
           (:) x xs →
             (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
[Done]

fix ([Int] → [Int])
    (λ nub ds →
       case ds of wild [Int]
         [] → [] Int
         (:) x xs →
           (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
[Done]

let worker ∷ [Int] → Set Int → [Int]
    worker =
      repN (fix ([Int] → [Int])
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs))))
in absN worker
[Done]

Forcing obligation: nub-assumption
Goal:
  fix ([Int] → [Int])
      ((.) ([Int] → Set Int → [Int]) ([Int] → [Int]) ([Int] → [Int]) absN
           ((.) ([Int] → [Int]) ([Int] → Set Int → [Int]) ([Int] → [Int]) repN
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs)))))
  ≡
  fix ([Int] → [Int])
      (λ nub ds →
         case ds of wild [Int]
           [] → [] Int
           (:) x xs →
             (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))Successfully proven: nub-assumption
let worker ∷ [Int] → Set Int → [Int]
    worker =
      repN (fix ([Int] → [Int])
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs))))
in absN worker
[Done]

let worker ∷ [Int] → Set Int → [Int]
    worker =
      repN (fix ([Int] → [Int])
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs))))
in absN worker
[Done]

repN (fix ([Int] → [Int])
          (λ nub ds →
             case ds of wild [Int]
               [] → [] Int
               (:) x xs →
                 (:) Int x
                     (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))))
[Done]

fix ([Int] → [Int])
    (λ nub ds →
       case ds of wild [Int]
         [] → [] Int
         (:) x xs →
           (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
[Done]

let nub ∷ [Int] → [Int]
    nub =
      fix ([Int] → [Int])
          (λ nub ds →
             case ds of wild [Int]
               [] → [] Int
               (:) x xs →
                 (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
in nub
[Done]

let nub ∷ [Int] → [Int]
    nub =
      let rec x ∷ [Int] → [Int]
              x =
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs))) x
      in x
in nub
[Done]

let rec x ∷ [Int] → [Int]
        x = λ ds →
          case ds of wild [Int]
            [] → [] Int
            (:) x xs →
              (:) Int x (x (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
in x
[Done]

let worker ∷ [Int] → Set Int → [Int]
    worker =
      repN (let rec x ∷ [Int] → [Int]
                    x = λ ds →
                      case ds of wild [Int]
                        [] → [] Int
                        (:) x xs →
                          (:) Int x
                              (x (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
            in x)
in absN worker
[Done]

let rec x ∷ [Int] → [Int]
        x = λ ds →
          case ds of wild [Int]
            [] → [] Int
            (:) x xs →
              (:) Int x (x (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
    worker ∷ [Int] → Set Int → [Int]
    worker = repN x
in absN worker
[Done]

let rec nub' ∷ [Int] → [Int]
        nub' = λ ds →
          case ds of wild [Int]
            [] → [] Int
            (:) x xs →
              (:) Int x (nub' (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
    worker ∷ [Int] → Set Int → [Int]
    worker = repN nub'
in absN worker
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = repN nub'
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
[Done]

'"Object (fromList [(\"params\",Array (fromList [Object (fromList [(\"params\",Array (fromList [String \"origworker\"])),(\"method\",String \"remember\")])])),(\"method\",String \"query\")])" [correct]

[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  nub' (case xs of wild [Int]
          [] → [] Int
          (:) x xs →
            case (λ ds → notMember Int $fOrdInt ds s) x of wild [Int]
              False → filter Int (λ ds → notMember Int $fOrdInt ds s) xs
              True →
                (:) Int x (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

*** Exception: failed to parse result value: Null : Object not returned from Server
HERMIT> Warning: Lemma nub-assumption was assumed but not proven.
nub-assumption
  fix ([Int] → [Int])
      ((.) ([Int] → Set Int → [Int]) ([Int] → [Int]) ([Int] → [Int]) absN
           ((.) ([Int] → [Int]) ([Int] → Set Int → [Int]) ([Int] → [Int]) repN
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs)))))
  ≡
  fix ([Int] → [Int])
      (λ nub ds →
         case ds of wild [Int]
           [] → [] Int
           (:) x xs →
             (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
[Done]

Leaving GHCi.
ghc: user interrupt
Linking Nub ...
[starting HERMIT-shell v0.1.0.0 on Nub.hs]
[starting HERMIT v1.0.0.0 on Nub.hs]
% ghc Nub.hs -fforce-recomp -O2 -dcore-lint -fsimple-list-literals -fexpose-all-unfoldings -fplugin=HERMIT.GHCI -fplugin-opt=HERMIT.GHCI:Main: -fplugin-opt=HERMIT.GHCI:Main:NubScript.hs -fplugin-opt=HERMIT.GHCI:Main:resume
