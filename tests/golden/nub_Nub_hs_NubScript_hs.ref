[1 of 1] Compiling Main             ( Nub.hs, Nub.o )

Nub.hs:26:11: Warning:
    Rule "filter-fusion" may never fire
      because ‘filter’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘filter’

Nub.hs:27:11: Warning:
    Rule "member-fusion" may never fire because ‘&&’ might inline first
    Probable fix: add an INLINE[n] or NOINLINE[n] pragma on ‘&&’
Setting phasers to stun... (port 3000) (ctrl-c to quit)
GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
module Main where
  absN ∷ ([Int] → Set Int → [Int]) → [Int] → [Int]
  filter ∷ ∀ a . (a → Bool) → [a] → [a]
  repN ∷ ([Int] → [Int]) → [Int] → Set Int → [Int]
  $dShow ∷ Show [Int]
  nub ∷ [Int] → [Int]
  main ∷ IO ()
  main ∷ IO ()
[Done]

[1 of 1] Compiling NubScript        ( NubScript.hs, interpreted )
Ok, modules loaded: NubScript.
module Main where
  absN ∷ ([Int] → Set Int → [Int]) → [Int] → [Int]
  filter ∷ ∀ a . (a → Bool) → [a] → [a]
  repN ∷ ([Int] → [Int]) → [Int] → Set Int → [Int]
  $dShow ∷ Show [Int]
  nub ∷ [Int] → [Int]
  main ∷ IO ()
  main ∷ IO ()
[Done]

module Main where
  absN ∷ ([Int] → Set Int → [Int]) → [Int] → [Int]
  filter ∷ ∀ a . (a → Bool) → [a] → [a]
  repN ∷ ([Int] → [Int]) → [Int] → Set Int → [Int]
  $dShow ∷ Show [Int]
  nub ∷ [Int] → [Int]
  main ∷ IO ()
  main ∷ IO ()
[Done]

nub ∷ [Int] → [Int]
nub = λ ds →
  case ds of wild [Int]
    [] → [] Int
    (:) x xs →
      (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
[Done]

nub ∷ [Int] → [Int]
nub =
  fix ([Int] → [Int])
      (λ nub ds →
         case ds of wild [Int]
           [] → [] Int
           (:) x xs →
             (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
[Done]

fix ([Int] → [Int])
    (λ nub ds →
       case ds of wild [Int]
         [] → [] Int
         (:) x xs →
           (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
[Done]

let worker ∷ [Int] → Set Int → [Int]
    worker =
      repN (fix ([Int] → [Int])
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs))))
in absN worker
[Done]

Forcing obligation: nub-assumption
Goal:
  fix ([Int] → [Int])
      ((.) ([Int] → Set Int → [Int]) ([Int] → [Int]) ([Int] → [Int]) absN
           ((.) ([Int] → [Int]) ([Int] → Set Int → [Int]) ([Int] → [Int]) repN
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs)))))
  ≡
  fix ([Int] → [Int])
      (λ nub ds →
         case ds of wild [Int]
           [] → [] Int
           (:) x xs →
             (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))Successfully proven: nub-assumption
let worker ∷ [Int] → Set Int → [Int]
    worker =
      repN (fix ([Int] → [Int])
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs))))
in absN worker
[Done]

let worker ∷ [Int] → Set Int → [Int]
    worker =
      repN (fix ([Int] → [Int])
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs))))
in absN worker
[Done]

repN (fix ([Int] → [Int])
          (λ nub ds →
             case ds of wild [Int]
               [] → [] Int
               (:) x xs →
                 (:) Int x
                     (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))))
[Done]

fix ([Int] → [Int])
    (λ nub ds →
       case ds of wild [Int]
         [] → [] Int
         (:) x xs →
           (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
[Done]

let nub ∷ [Int] → [Int]
    nub =
      fix ([Int] → [Int])
          (λ nub ds →
             case ds of wild [Int]
               [] → [] Int
               (:) x xs →
                 (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
in nub
[Done]

let nub ∷ [Int] → [Int]
    nub =
      let rec x ∷ [Int] → [Int]
              x =
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs))) x
      in x
in nub
[Done]

let rec x ∷ [Int] → [Int]
        x = λ ds →
          case ds of wild [Int]
            [] → [] Int
            (:) x xs →
              (:) Int x (x (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
in x
[Done]

let worker ∷ [Int] → Set Int → [Int]
    worker =
      repN (let rec x ∷ [Int] → [Int]
                    x = λ ds →
                      case ds of wild [Int]
                        [] → [] Int
                        (:) x xs →
                          (:) Int x
                              (x (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
            in x)
in absN worker
[Done]

let rec x ∷ [Int] → [Int]
        x = λ ds →
          case ds of wild [Int]
            [] → [] Int
            (:) x xs →
              (:) Int x (x (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
    worker ∷ [Int] → Set Int → [Int]
    worker = repN x
in absN worker
[Done]

let rec nub' ∷ [Int] → [Int]
        nub' = λ ds →
          case ds of wild [Int]
            [] → [] Int
            (:) x xs →
              (:) Int x (nub' (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
    worker ∷ [Int] → Set Int → [Int]
    worker = repN nub'
in absN worker
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = repN nub'
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
[Done]

'"{
    \"params\": [
        {
            \"params\": [
                \"origworker\"
            ],
            \"method\": \"remember\"
        }
    ],
    \"method\": \"query\"
}" [correct]

[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  nub' (case xs of wild [Int]
          [] → [] Int
          (:) x xs →
            case (λ ds → notMember Int $fOrdInt ds s) x of wild [Int]
              False → filter Int (λ ds → notMember Int $fOrdInt ds s) xs
              True →
                (:) Int x (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  case xs of wild [Int]
    [] → nub' ([] Int)
    (:) x xs →
      nub' (case (λ ds → notMember Int $fOrdInt ds s) x of wild [Int]
              False → filter Int (λ ds → notMember Int $fOrdInt ds s) xs
              True →
                (:) Int x (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

Forcing obligation: nubStrict
Goal:
  nub' (undefined [Int]) ≡ undefined [Int]Goal:
  case undefined [Int] of wild [Int]
    [] → [] Int
    (:) x xs →
      (:) Int x (nub' (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
  ≡
  undefined [Int]
[Done]

Goal:
  true
[Done]

Successfully proven: nubStrict
worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  case xs of wild [Int]
    [] → nub' ([] Int)
    (:) x xs →
      nub' (case (λ ds → notMember Int $fOrdInt ds s) x of wild [Int]
              False → filter Int (λ ds → notMember Int $fOrdInt ds s) xs
              True →
                (:) Int x (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  case xs of wild [Int]
    [] →
      case [] Int of wild [Int]
        [] → [] Int
        (:) x xs →
          (:) Int x (nub' (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
    (:) x xs →
      nub' (case (λ ds → notMember Int $fOrdInt ds s) x of wild [Int]
              False → filter Int (λ ds → notMember Int $fOrdInt ds s) xs
              True →
                (:) Int x (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  case xs of wild [Int]
    [] → [] Int
    (:) x xs →
      nub' (case notMember Int $fOrdInt x s of wild [Int]
              False → filter Int (λ ds → notMember Int $fOrdInt ds s) xs
              True →
                (:) Int x (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  case xs of wild [Int]
    [] → [] Int
    (:) x xs →
      case notMember Int $fOrdInt x s of wild [Int]
        False → nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
        True →
          nub' ((:) Int x
                    (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

Forcing obligation: nubStrict
Goal:
  nub' (undefined [Int]) ≡ undefined [Int]Goal:
  case undefined [Int] of wild [Int]
    [] → [] Int
    (:) x xs →
      (:) Int x (nub' (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
  ≡
  undefined [Int]
[Done]

Goal:
  true
[Done]

Successfully proven: nubStrict
worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  case xs of wild [Int]
    [] → [] Int
    (:) x xs →
      case notMember Int $fOrdInt x s of wild [Int]
        False → nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
        True →
          nub' ((:) Int x
                    (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  case xs of wild [Int]
    [] → [] Int
    (:) x xs →
      case notMember Int $fOrdInt x s of wild [Int]
        False → nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
        True →
          nub' ((:) Int x
                    (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

case xs of wild [Int]
  [] → [] Int
  (:) x xs →
    case notMember Int $fOrdInt x s of wild [Int]
      False → nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
      True →
        nub' ((:) Int x
                  (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

case notMember Int $fOrdInt x s of wild [Int]
  False → nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
  True →
    nub' ((:) Int x
              (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

True →
  nub' ((:) Int x
            (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

nub' ((:) Int x
          (filter Int (λ ds → notMember Int $fOrdInt ds s) xs))
[Done]

case (:) Int x (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
 of wild [Int]
  [] → [] Int
  (:) x xs →
    (:) Int x (nub' (filter Int (λ ds → (/=) Int $fEqInt ds x) xs))
[Done]

(:) Int x
    (nub' (filter Int (λ ds → (/=) Int $fEqInt ds x)
                  (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)))
[Done]

(:) Int x
    (nub' (filter Int
                  (λ y →
                     (&&) ((λ ds → (/=) Int $fEqInt ds x) y)
                          ((λ ds → notMember Int $fOrdInt ds s) y))
                  xs))
[Done]

Forcing obligation: filter-fusion
Goal:
  ∀ a p q ys.
  filter a p (filter a q ys) ≡ filter a (λ y → (&&) (p y) (q y)) ysSuccessfully proven: filter-fusion
(:) Int x
    (nub' (filter Int
                  (λ y →
                     (&&) ((λ ds → (/=) Int $fEqInt ds x) y)
                          ((λ ds → notMember Int $fOrdInt ds s) y))
                  xs))
[Done]

(:) Int x
    (nub' (filter Int
                  (λ y →
                     (&&) ((/=) Int $fEqInt y x) (notMember Int $fOrdInt y s))
                  xs))
[Done]

(:) Int x
    (nub' (filter Int
                  (λ y → notMember Int $fOrdInt y (insert Int $fOrdInt x s))
                  xs))
[Done]

Forcing obligation: member-fusion
Goal:
  ∀ a $dEq $dOrd y x s.
  (&&) ((/=) a $dEq y x) (notMember a $dOrd y s)
  ≡
  notMember a $dOrd y (insert a $dOrd x s)Successfully proven: member-fusion
(:) Int x
    (nub' (filter Int
                  (λ y → notMember Int $fOrdInt y (insert Int $fOrdInt x s))
                  xs))
[Done]

worker ∷ [Int] → Set Int → [Int]
worker = λ xs s →
  case xs of wild [Int]
    [] → [] Int
    (:) x xs →
      case notMember Int $fOrdInt x s of wild [Int]
        False → nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
        True →
          (:) Int x
              (nub' (filter Int
                            (λ y →
                               notMember Int $fOrdInt y
                                         (insert Int $fOrdInt x s))
                            xs))
[Done]

rec worker ∷ [Int] → Set Int → [Int]
    worker = λ xs s →
      case xs of wild [Int]
        [] → [] Int
        (:) x xs →
          case notMember Int $fOrdInt x s of wild [Int]
            False → nub' (filter Int (λ ds → notMember Int $fOrdInt ds s) xs)
            True →
              (:) Int x
                  (nub' (filter Int
                                (λ y →
                                   notMember Int $fOrdInt y
                                             (insert Int $fOrdInt x s))
                                xs))
[Done]

rec worker ∷ [Int] → Set Int → [Int]
    worker = λ xs s →
      case xs of wild [Int]
        [] → [] Int
        (:) x xs →
          case notMember Int $fOrdInt x s of wild [Int]
            False → worker xs s
            True → (:) Int x (worker xs (insert Int $fOrdInt x s))
[Done]

HERMIT> Warning: Lemma filter-fusion was assumed but not proven.
filter-fusion
  ∀ a p q ys.
  filter a p (filter a q ys) ≡ filter a (λ y → (&&) (p y) (q y)) ysWarning: Lemma member-fusion was assumed but not proven.
member-fusion
  ∀ a $dEq $dOrd y x s.
  (&&) ((/=) a $dEq y x) (notMember a $dOrd y s)
  ≡
  notMember a $dOrd y (insert a $dOrd x s)Warning: Lemma nub-assumption was assumed but not proven.
nub-assumption
  fix ([Int] → [Int])
      ((.) ([Int] → Set Int → [Int]) ([Int] → [Int]) ([Int] → [Int]) absN
           ((.) ([Int] → [Int]) ([Int] → Set Int → [Int]) ([Int] → [Int]) repN
                (λ nub ds →
                   case ds of wild [Int]
                     [] → [] Int
                     (:) x xs →
                       (:) Int x
                           (nub (filter Int (λ ds → (/=) Int $fEqInt ds x)
                                        xs)))))
  ≡
  fix ([Int] → [Int])
      (λ nub ds →
         case ds of wild [Int]
           [] → [] Int
           (:) x xs →
             (:) Int x (nub (filter Int (λ ds → (/=) Int $fEqInt ds x) xs)))
[Done]

Leaving GHCi.
ghc: user interrupt
Linking Nub ...
[starting HERMIT-shell v0.1.0.0 on Nub.hs]
[starting HERMIT v1.0.0.0 on Nub.hs]
% ghc Nub.hs -fforce-recomp -O2 -dcore-lint -fsimple-list-literals -fexpose-all-unfoldings -fplugin=HERMIT.GHCI -fplugin-opt=HERMIT.GHCI:Main: -fplugin-opt=HERMIT.GHCI:Main:NubScript.hs -fplugin-opt=HERMIT.GHCI:Main:resume
